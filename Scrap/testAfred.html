<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spiel</title>

    <style>
        canvas {
            border: 1px solid black
        }
    </style>
</head>

<body onload="starte()">

    <canvas height="1000" width="1800" id="canvas" onload="test()"></canvas>
    <br>
    <script>
        let canvas;
        let ctx;
        let deathSreen = new Image();
        let onGround = false;
        let tickerZeit = 5;
        let hindernisse = [];
        let renderedistance = 1000;
        let intervall = setInterval(ticke, tickerZeit); // setzt den tick speed 

        let ZeitLetzte = Date.now()
        let ZeitStart = Date.now()
        let counter = 0;
        let counterCont = 0;
        let counterContStart = 0;

        for (var i = 0; i < 20000; i++) {
            //zwischen Position 1000 und Position 1800 ist ein Hindernis auf -1800 Pixeln
            hindernisse[i] = [1, -850, -1000]
        }
        //console.log(hindernisse)

        let generalRF = {
            x: -100,
            y: 400
        }
        let beschl = {
            x: 0,
            y: 0.1
        }
        let geschw = {
            x: 0,
            y: 0
        }
        let character = {
            defaultHight: 100,
            defaultSpeed: 3,
            hight: 100,
            breite: 50,
            health: 7,
            munition: 10,
            facingRight: true,
            bild: new Image(),
            cooldownAngriff: Date.now(),
        }



        let bildArray = [{
            bild: new Image(),
            xPos: 0,
            yPos: 0,
            breite: 8000,
            höhe: 1000,
            hindernis: false,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 0,
            yPos: 0,
            breite: 10000,
            höhe: 1000,
            hindernis: false,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 0,
            yPos: 0,
            breite: 10,
            höhe: 3000,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 0,
            yPos: 0,
            breite: 10000,
            höhe: 1000,
            hindernis: false,
            schräge: false
        }, {
            bild: new Image(), //Box 1
            xPos: 750,
            yPos: 791,
            breite: 130,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(), //Box 2
            xPos: 1283,
            yPos: 791,
            breite: 122,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(), //Box 3
            xPos: 1300,
            yPos: 736,
            breite: 122,
            höhe: 50,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 2180,
            yPos: 785,
            breite: 70,
            höhe: 50,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 2240,
            yPos: 705,
            breite: 570,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 2810,
            yPos: 650,
            breite: 180,
            höhe: 80,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 3070,
            yPos: 705,
            breite: 870,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 3100,
            yPos: 560,
            breite: 290,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 3140,
            yPos: 410,
            breite: 150,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 3515,
            yPos: 635,
            breite: 65,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 3930,
            yPos: 785,
            breite: 75,
            höhe: 100,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 4080,
            yPos: 700,
            breite: 230,
            höhe: 10,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 4350,
            yPos: 605,
            breite: 230,
            höhe: 15,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 4650,
            yPos: 435,
            breite: 650,
            höhe: 50,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(),
            xPos: 5370,
            yPos: 435,
            breite: 660,
            höhe: 50,
            hindernis: true,
            schräge: false
        }, {
            bild: new Image(), //Polizeiauto
            xPos: 5040,
            yPos: 215,
            breite: 213,
            höhe: 200,
            hindernis: true,
            schräge: false
        }];

        let schussArray = [{
            xPosition: 0,
            yPosi: 0,
            breite: 0,
            höhe: 0,
            xGeschw: 0
        }];

        let gegnerArray = [{
            xPos: 300,
            yPos: 400,
            breite: 50,
            höhe: 100,
            xGeschw: 0,
            yGeshwi: 0,
            defaultGeschwindigkeit: 1,
            typ: "melee",
            bild: new Image(),
            health: 1,
            onGround: false,
        }, {
            xPos: 400,
            yPos: 500,
            breite: 50,
            höhe: 100,
            xGeschw: 0,
            yGeschw: 0,
            defaultGeschwindigkeit: 2,
            typ: "melee",
            bild: new Image(),
            health: 1,
            onGround: false,
        }];


        let overlay = [{
            name: "Lebensanzeige",
            bild: new Image(),
            xPos: 0,
            yPos: 0,
            briete: 200,
            höhe: 100,
        }, {
            name: "Magazinanzeige",
            bild: new Image(),
            xPos: 220,
            yPos: 0,
            briete: 100,
            höhe: 100,
        }];


















        // hier stehen die Sachen direkt beim laden ausgeführt werden müssen 

        // ist der key listener 
        var map = [];
        let pausiert = false;
        document.onkeydown = document.onkeyup = function(e) {
            e = e || event;
            map[e.keyCode] = e.type == 'keydown';
            /* insert conditional here */
        }



        //start() wird ausgeführt sobald die Seite geladen wird
        function starte() {
            //der Variable canvas wird das Element mit der ID "canvas" zugewiesen (der Canvas der im HTML teil erstellt wurde)
            canvas = document.getElementById('canvas');

            //ctx ist der canvas, auf ihn wird zugegriffen um zu malen oder bilder einzufügen oder...
            ctx = canvas.getContext('2d');

            //erstellt eine neue variable, die ein bild mit dieser Adresse ist
            //bilder.bild = new Image();
            bildArray[0].bild.src = "./Bilder/Level 1/Level1_11200x1080_V3.1_hintergrund_1.png";
            bildArray[1].bild.src = "./Bilder/Level 1/Level1_11200x1080_V3.2_hintergrund_2.png";
            bildArray[2].bild.src = "./Bilder/Level 1/Level1_11200x1080_V3.3_vordergrund.png";
            bildArray[3].bild.src = "./Bilder/Level 1/Level1_11200x1080_V3.3_vordergrund.png";

            //overlay[1].bild.src = "/Bilder/IO/Health" + character.health + ".gif";


            character.bild.src = "./Bilder/Objekte/PNG/Foreground/Hindernisse/Car_Side_1.png";
            deathSreen.src = "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fxboxer.sk%2Fwp-content%2Fuploads%2F2018%2F05%2FYou-Died.jpg&f=1&nofb=1";

            gegnerArray[0].bild.src = "https://external-content.duckduckgo.com/iu/?u=http%3A%2F%2Fimages4.wikia.nocookie.net%2F__cb20120520175235%2Ffantendo%2Fimages%2F2%2F28%2FMP9_Lakitu_Bust.png&f=1&nofb=1";
            gegnerArray[1].bild.src = "https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fvignette.wikia.nocookie.net%2Fvsbattles%2Fimages%2F3%2F3d%2FNotAMarioFan_pic_7.png%2Frevision%2Flatest%3Fcb%3D20160515161637&f=1&nofb=1";

            hindernisseHinzufuegen();
            console.log(hindernisse)
        }


        function hindernisseHinzufuegen() {

            for (j = 1; j < bildArray.length; j++) {
                if (bildArray[j].hindernis) {
                    addPlatform(bildArray[j].xPos, -bildArray[j].yPos, bildArray[j].breite, bildArray[j].höhe);
                    console.log("Hinderniss " + j + " hinzugefügt");
                }
                if (bildArray[j].schräge) {
                    addPlatformSchräge(bildArray[j].xPos, bildArray[j].schrägeStart, bildArray[j].breite, bildArray[j].schrägeEnd, 20);
                    console.log("schräge    " + j + " hinzugefügt");
                }
            }
        }

        function addPlatform(xKoord, yKoord, br, hgt) {
            for (i = (0 + xKoord); i < (br + xKoord); i++) {
                hindernisse[i][0] += 1;
                hindernisse[i].push(yKoord, (yKoord - hgt));
            }
        }

        function addPlatformSchräge(xKoord, yKoord, br, schrägeEnd, tiefe) {
            let tempI = 0;
            for (i = (0 + xKoord); i < (br + xKoord); i++) {
                tempI += 1;
                hindernisse[i][0] += 1;
                hindernisse[i].push(-(yKoord - tempI * ((yKoord - schrägeEnd) / br)), -(yKoord - tempI * ((yKoord - schrägeEnd) / br)) - tiefe);
            }
        }














        //hier stehen die akktionnen, welche jeden Tick ausgeführt werden 

        function ticke() {
            // console.log("tick");
            //console.log(generalRF.x + " " + generalRF.y)
            bewegeSpieler()
            bewegeBild();
            if (generalRF.x < -900) {
                zeichneBild()
            } else {
                zeichneBildStart()
            }
            bewegeSchuss(); //ruft auch die Methode zum zeichnen den Schüssen auf 
            bewegeGegner();
            nochAmLeben();
        }


        function bewegeSpieler() {
            //nach links laufen auf "s"
            if (map[65]) {
                geschw.x = -character.defaultSpeed;
                character.facingRight = false;
            } else {
                geschw.x = 0;
            }


            //nach rechts laufen auf "d"
            if (map[68]) {
                geschw.x = character.defaultSpeed;
                character.facingRight = true;
            } else if (geschw.x > 0) {
                geschw.x = 0;
            }

            // sneaken auf "s" oder "Strg"
            if (map[17] || map[83]) {
                if (onGround) {
                    character.hight = character.defaultHight / 2;
                }
            } else if (character.hight <= character.defaultHight) {
                character.hight = character.defaultHight;
            }

            //sprinten (klappt noch nicht )
            /*
            if (map[16]) {
                geschw.x = character.defaultSpeed * 2;
            } else if (geschw.x != 0) {
                geschw.x = geschw.x / 2;
            }
            */

            //range attack auf "f"
            if (map[70]) {
                schuss();
                console.log("es wurde geschossen");
            }

            //close Combet attack auf "e"
            if (map[69]) {
                schlagen();
                console.log("es wurde geschlagen");
            }

            //springen auf space
            if (map[32]) {
                //y-Geschwindigkeit wird nach oben gesetzt, wenn der Spieler auf dem Boden ist
                if (onGround) {
                    geschw.y = -6;
                }
            }

            //pause auf "esc"
            if (map[27] && pausiert) {
                intervall = setInterval(ticke, 5);
                pausiert = false;
            } else if (map[27] && !pausiert) {
                clearInterval(intervall);
                pausiert = true;
            }

            //zum testen die taste "t"
            //setzt gerade die lebne auf 0 
            if (map[84]) {
                character.health = 0;
            }

        }

        function bewegeBild() {
            geschw.y = geschw.y + beschl.y;
            let yh; // yh ist die y-coordinate, auf der die Oberfläche des objektes ist, auf welcher der Character steht 
            onGround = istHindernis(generalRF.x, generalRF.y);

            if (onGround) {
                yh = hindernisse[-generalRF.x][(i * 2) + 1];
            }

            if (istHindernis(generalRF.x, (generalRF.y + character.hight))) {
                console.log("kopf gestoßen");
                if (geschw.y < 0) {
                    geschw.y = 0;
                }
            }

            if (istHindernis((generalRF.x + character.breite / 2), (generalRF.y + character.hight / 2))) {
                console.log("links gestoßen");
                if (geschw.x < 0) {
                    geschw.x = 0;
                }
            }

            if (istHindernis((generalRF.x - character.breite / 2), (generalRF.y + character.hight / 2))) {
                console.log("rechts gestoßen");
                if (geschw.x > 0) {
                    geschw.x = 0;
                }
            }

            if (!onGround) {
                generalRF.x = generalRF.x - geschw.x;
                generalRF.y = generalRF.y - geschw.y;
                onGround = false;
            } else {
                onGround = true;
                generalRF.y = yh;
                if (geschw.y < 0) {
                    generalRF.y = generalRF.y - geschw.y;
                } else {
                    geschw.y = 0;
                }
                generalRF.x = generalRF.x - geschw.x;
            }
        }

        function istHindernis(xPosi, yPosi) {
            for (i = 0; i < hindernisse[-xPosi][0]; i++) {

                if (yPosi <= hindernisse[-xPosi][(i * 2) + 1] && yPosi >= hindernisse[-xPosi][(i * 2) + 2]) {
                    return true;
                }
            }
        }

        function zeichneBild() {
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.height, canvas.width);

            ctx.drawImage(bildArray[0].bild, ((generalRF.x + 900) / 2) + bildArray[0].xPos, bildArray[0].yPos, bildArray[0].breite, bildArray[0].höhe);
            ctx.drawImage(bildArray[1].bild, ((generalRF.x + 900) / 1.5) + bildArray[1].xPos, bildArray[1].yPos, bildArray[1].breite, bildArray[1].höhe);
            ctx.drawImage(bildArray[2].bild, ((generalRF.x + 900) / 2) + bildArray[2].xPos, bildArray[2].yPos, bildArray[2].breite, bildArray[2].höhe);

            //ctx.drawImage(overlay[1].bild, 0, 0, 200, 100);

            //Zeichnet den Bild Array 
            for (i = 3; i < bildArray.length; i++) {
                ctx.drawImage(bildArray[i].bild, generalRF.x + bildArray[i].xPos + 900 + character.breite / 2, bildArray[i].yPos, bildArray[i].breite, bildArray[i].höhe);
            }

            //Zeichnet Gegner aus gegnerArray (mit hitboxen)
            for (i = 0; i < gegnerArray.length; i++) {
                ctx.drawImage(gegnerArray[i].bild, generalRF.x + gegnerArray[i].xPos + 900 + character.breite / 2, gegnerArray[i].yPos, gegnerArray[i].breite, gegnerArray[i].höhe);
                ctx.fillStyle = '#F0DB4F';
                ctx.strokeStyle = 'red';
                ctx.strokeRect(generalRF.x + gegnerArray[i].xPos + 900 + character.breite / 2, gegnerArray[i].yPos, gegnerArray[i].breite, gegnerArray[i].höhe);
            }
            zeichneCharacter(900, -generalRF.y - character.hight);
            zeichneSchuss();
        }

        function zeichneBildStart() {

            ctx.drawImage(bildArray[0].bild, bildArray[0].xPos, bildArray[0].yPos, bildArray[0].breite, bildArray[0].höhe);
            ctx.drawImage(bildArray[1].bild, bildArray[1].xPos, bildArray[1].yPos, bildArray[1].breite, bildArray[1].höhe);
            ctx.drawImage(bildArray[2].bild, bildArray[2].xPos, bildArray[2].yPos, bildArray[2].breite, bildArray[2].höhe);

            for (i = 3; i < bildArray.length; i++) {
                ctx.drawImage(bildArray[i].bild, bildArray[i].xPos + character.breite / 2, bildArray[i].yPos, bildArray[i].breite, bildArray[i].höhe);

            }
            for (i = 0; i < gegnerArray.length; i++) {
                ctx.drawImage(gegnerArray[i].bild, gegnerArray[i].xPos + character.breite / 2, gegnerArray[i].yPos, gegnerArray[i].breite, gegnerArray[i].höhe);
                ctx.fillStyle = '#F0DB4F';
                ctx.strokeStyle = 'red';
                ctx.strokeRect(gegnerArray[i].xPos + character.breite / 2, gegnerArray[i].yPos, gegnerArray[i].breite, gegnerArray[i].höhe);
            }
            zeichneCharacter(-generalRF.x, -generalRF.y - character.hight);
            zeichneSchussStart();
        }


        function zeichneCharacter(xPos, yPos) {
            ctx.fillStyle = '#F0DB4F';
            ctx.strokeStyle = 'red';
            ctx.strokeRect(xPos, yPos, character.breite, character.hight);
            ctx.drawImage(character.bild, xPos, yPos, character.breite, character.hight);
        }

        function bewegeSchuss() {
            for (i = 1; i < schussArray.length; i++) {

                schussArray[i].xPosition -= schussArray[i].xGeschw;

                if (schussArray[i].xPosition - generalRF.x / 2 >= renderedistance) {
                    schussArray.splice(i, 1);

                } else if (schussArray[i].xPosition - generalRF.x / 2 <= -renderedistance) {
                    schussArray.splice(i, 1);
                }
            }
        }

        function zeichneSchuss() {
            ctx.fillStyle = '#F0DB4F';
            ctx.strokeStyle = 'red';

            // Ein ausgemaltes Rechteck malen
            for (i = 1; i < schussArray.length; i++) {

                ctx.fillRect(-schussArray[i].xPosition + generalRF.x / 2 + 900, -schussArray[i].yPosi, schussArray[i].breite, schussArray[i].höhe);
            }
        }

        function zeichneSchussStart() {
            ctx.fillStyle = '#F0DB4F';
            ctx.strokeStyle = 'red';

            // Ein ausgemaltes Rechteck malen
            for (i = 1; i < schussArray.length; i++) {

                ctx.fillRect(-schussArray[i].xPosition - generalRF.x / 2, -schussArray[i].yPosi, schussArray[i].breite, schussArray[i].höhe);
            }
        }


        function bewegeGegner() {
            for (g = 0; g < gegnerArray.length; g++) {

                //gegner laufen dem Spieler hinterher 
                if (-generalRF.x < gegnerArray[g].xPos) {
                    gegnerArray[g].xGeschw = gegnerArray[g].defaultGeschwindigkeit;
                    if (gegnerArray[g].xPos - gegnerArray[g].xGeschw > -generalRF.x) {
                        gegnerArray[g].xPos -= gegnerArray[g].xGeschw;
                    } else if (gegnerArray[g].xPos - gegnerArray[g].xGeschw < -generalRF.x) {
                        gegnerArray[g].xPos = -generalRF.x;
                    }
                } else if (-generalRF.x > gegnerArray[g].xPos) {
                    gegnerArray[g].xGeschw = -gegnerArray[g].defaultGeschwindigkeit;
                    if (gegnerArray[g].xPos - gegnerArray[g].xGeschw < -generalRF.x) {
                        gegnerArray[g].xPos -= gegnerArray[g].xGeschw;
                    } else if (gegnerArray[g].xPos - gegnerArray[g].xGeschw > -generalRF.x) {
                        gegnerArray[g].xPos = -generalRF.x;
                    }
                }

                //fallbeschleunigung der Gegner (klappt nicht fehler in "kolidiert()", was eine Kopie von "istHindernis()" ist)
                /*
                                gegnerArray[g].onGround = kolidiert(gegnerArray[g].xPos + (gegnerArray[g].breite / 2) , gegnerArray[g].yPos + gegnerArray[g].höhe )
                                console.log("Gegner " + i + " onGround: " + gegnerArray[g].onGround) 
                if (gegnerArray[g].onGround == false) {
                    gegnerArray[g].yGeschw -= 0,5;
                    console.log("Gegner: " + i + "  yPos: " + gegnerArray[g].yPos);
                    gegnerArray[g].yPos -= gegnerArray[g].yGeschw;
                } else {
                    gegnerArray[g].yGeschw = 0;
                }*/

            }
        }

        //klappt nicht 
        function kolidiert(xPosi, yPosi) {
            for (i = 0; i < hindernisse[-xPosi][0]; i++) {

                if (yPosi <= hindernisse[-xPosi][(i * 2) + 1] && yPosi >= hindernisse[-xPosi][(i * 2) + 2]) {
                    return true;
                }
            }
        }



        function nochAmLeben() {
            if (character.health == 0) {
                ctx.drawImage(deathSreen, 0, 0, 1800, 1000);
                clearInterval(intervall);
            }
        }





















        // hier stehen die Aktionen des Characters

        function schuss() {
            if (character.cooldownAngriff + 300 <= Date.now() && character.munition > 0) {
                if (character.facingRight == false) {
                    geschwitemp = -14;
                } else {
                    geschwitemp = 14;
                }
                schussArray.push({ //"array.push" verlängert den array und setzt in das neue "feld" am ender des arrays ein neues Objekt

                        yPosi: generalRF.y + character.hight / 2,
                        breite: 15,
                        höhe: 5,
                        xGeschw: geschwitemp,
                        xPosition: generalRF.x / 2 - character.breite / 2 - geschwitemp
                    })
                    //console.log(schussArray)
                character.cooldownAngriff = Date.now()
                character.munition = character.munition - 1;
                console.log(character.munition + " Schuss übrig");
            }
        }

        //muss noch eingefügt werdcen 
        function schlagen() {
            // richtung des Schlages 
            // erkennen, ob treffer 
            // animation
        }







        function fps() {
            if (counter < 1) {
                counter++;
                counterCont++;

            } else {
                if (counterContStart > 100) {
                    console.log("   Avg: " + (1000 * counterCont / (Date.now() - ZeitStart)))
                    counterCont++;
                } else {
                    ZeitStart = Date.now()
                }
                console.log((1000 / (Date.now() - ZeitLetzte)))
                counterContStart++;

                ZeitLetzte = Date.now()
                counter = 1;
            }
        }


        const ctx = canvas.getContext("2d");

        var myGif;
        // Can not load gif cross domain unless it has CORS header
        const gifURL = "https://upload.wikimedia.org/wikipedia/commons/a/a2/Wax_fire.gif";
        // timeout just waits till script has been parsed and executed
        // then starts loading a gif
        setTimeout(() => {
            myGif = GIF(); // creates a new gif  
            myGif.onerror = function(e) {
                console.log("Gif loading error " + e.type);
            }
            myGif.load(gifURL);

        }, 0);
        // Function draws an image
        function drawImage(image, x, y, scale, rot) {
            ctx.setTransform(scale, 0, 0, scale, x, y);
            ctx.rotate(rot);
            ctx.drawImage(image, -image.width / 2, -image.height / 2);
        }
        // helper functions
        const rand = (min = 1, max = min + (min = 0)) => Math.random() * (max - min) + min;
        const setOf = (c, C) => {
            var a = [],
                i = 0;
            while (i < c) {
                a.push(C(i++))
            }
            return a
        };
        const eachOf = (a, C) => {
            var i = 0;
            const l = a.length;
            while (i < l && C(a[i], i++, l) !== true);
            return i
        };
        const mod = (v, m) => ((v % m) + m) % m;

        // create 100 particles
        const particles = setOf(100, () => {
            return {
                x: rand(innerWidth),
                y: rand(innerHeight),
                scale: rand(0.15, 0.5),
                rot: rand(Math.PI * 2),
                frame: 0,
                frameRate: rand(-2, 2),
                dr: rand(-0.1, 0.1),
                dx: rand(-4, 4),
                dy: rand(-4, 4),
            };
        });
        // Animate and draw 100 particles
        function drawParticles() {
            eachOf(particles, part => {
                part.x += part.dx;
                part.y += part.dy;
                part.rot += part.dr;
                part.frame += part.frameRate;
                part.x = mod(part.x, innerWidth);
                part.y = mod(part.y, innerHeight);
                var frame = mod(part.frame, myGif.frames.length) | 0;

                drawImage(myGif.frames[frame].image, part.x, part.y, part.scale, part.rot);
            });
        }


        var w = canvas.width;
        var h = canvas.height;
        var cw = w / 2; // center 
        var ch = h / 2;

        // main update function
        function update(timer) {
            ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
            if (w !== innerWidth || h !== innerHeight) {
                cw = (w = canvas.width = innerWidth) / 2;
                ch = (h = canvas.height = innerHeight) / 2;
            } else {
                ctx.clearRect(0, 0, w, h);
            }
            if (myGif) { // If gif object defined
                if (!myGif.loading) { // if loaded
                    // draw random access to gif frames
                    drawParticles();
                    drawImage(myGif.image, cw, ch, 1, 0); // displays the current frame.
                } else if (myGif.lastFrame !== null) { // Shows frames as they load
                    ctx.drawImage(myGif.lastFrame.image, 0, 0);
                    ctx.fillStyle = "white";
                    ctx.fillText("GIF loading frame " + myGif.frames.length, 10, 21);
                    ctx.fillText("GIF loading frame " + myGif.frames.length, 10, 19);
                    ctx.fillText("GIF loading frame " + myGif.frames.length, 9, 20);
                    ctx.fillText("GIF loading frame " + myGif.frames.length, 11, 20);
                    ctx.fillStyle = "black";
                    ctx.fillText("GIF loading frame " + myGif.frames.length, 10, 20);

                }

            } else {
                ctx.fillText("Waiting for GIF image ", 10, 20);

            }
            requestAnimationFrame(update);
        }
        requestAnimationFrame(update);

        /*============================================================================
          Gif Decoder and player for use with Canvas API's

        **NOT** for commercial use.

        To use

            var myGif = GIF();                  // creates a new gif  
            var myGif = new GIF();              // will work as well but not needed as GIF() returns the correct reference already.    
            myGif.load("myGif.gif");            // set URL and load
            myGif.onload = function(event){     // fires when loading is complete
                                                //event.type   = "load"
                                                //event.path   array containing a reference to the gif
            }
            myGif.onprogress = function(event){ // Note this function is not bound to myGif
                                                //event.bytesRead    bytes decoded
                                                //event.totalBytes   total bytes
                                                //event.frame        index of last frame decoded
            }
            myGif.onerror = function(event){    // fires if there is a problem loading. this = myGif
                                                //event.type   a description of the error
                                                //event.path   array containing a reference to the gif
            }

        Once loaded the gif can be displayed
            if(!myGif.loading){
                ctx.drawImage(myGif.image,0,0); 
            }
        You can display the last frame loaded during loading

            if(myGif.lastFrame !== null){
                ctx.drawImage(myGif.lastFrame.image,0,0); 
            }


        To access all the frames
            var gifFrames = myGif.frames; // an array of frames.

        A frame holds various frame associated items.
            myGif.frame[0].image; // the first frames image
            myGif.frame[0].delay; // time in milliseconds frame is displayed for




        Gifs use various methods to reduce the file size. The loaded frames do not maintain the optimisations and hold the full resolution frames as DOM images. This mean the memory footprint of a decode gif will be many time larger than the Gif file.
         */
        const GIF = function() {
            // **NOT** for commercial use.
            var timerID; // timer handle for set time out usage
            var st; // holds the stream object when loading.
            var interlaceOffsets = [0, 4, 2, 1]; // used in de-interlacing.
            var interlaceSteps = [8, 8, 4, 2];
            var interlacedBufSize; // this holds a buffer to de interlace. Created on the first frame and when size changed
            var deinterlaceBuf;
            var pixelBufSize; // this holds a buffer for pixels. Created on the first frame and when size changed
            var pixelBuf;
            const GIF_FILE = { // gif file data headers
                GCExt: 0xF9,
                COMMENT: 0xFE,
                APPExt: 0xFF,
                UNKNOWN: 0x01, // not sure what this is but need to skip it in parser
                IMAGE: 0x2C,
                EOF: 59, // This is entered as decimal
                EXT: 0x21,
            };
            // simple buffered stream used to read from the file 
            var Stream = function(data) {
                this.data = new Uint8ClampedArray(data);
                this.pos = 0;
                var len = this.data.length;
                this.getString = function(count) { // returns a string from current pos of len count
                    var s = "";
                    while (count--) {
                        s += String.fromCharCode(this.data[this.pos++])
                    }
                    return s;
                };
                this.readSubBlocks = function() { // reads a set of blocks as a string
                    var size, count, data = "";
                    do {
                        count = size = this.data[this.pos++];
                        while (count--) {
                            data += String.fromCharCode(this.data[this.pos++])
                        }
                    } while (size !== 0 && this.pos < len);
                    return data;
                }
                this.readSubBlocksB = function() { // reads a set of blocks as binary
                    var size, count, data = [];
                    do {
                        count = size = this.data[this.pos++];
                        while (count--) {
                            data.push(this.data[this.pos++]);
                        }
                    } while (size !== 0 && this.pos < len);
                    return data;
                }
            };
            // LZW decoder uncompressed each frames pixels
            // this needs to be optimised.
            // minSize is the min dictionary as powers of two
            // size and data is the compressed pixels
            function lzwDecode(minSize, data) {
                var i, pixelPos, pos, clear, eod, size, done, dic, code, last, d, len;
                pos = pixelPos = 0;
                dic = [];
                clear = 1 << minSize;
                eod = clear + 1;
                size = minSize + 1;
                done = false;
                while (!done) { // JavaScript optimisers like a clear exit though I never use 'done' apart from fooling the optimiser
                    last = code;
                    code = 0;
                    for (i = 0; i < size; i++) {
                        if (data[pos >> 3] & (1 << (pos & 7))) {
                            code |= 1 << i
                        }
                        pos++;
                    }
                    if (code === clear) { // clear and reset the dictionary
                        dic = [];
                        size = minSize + 1;
                        for (i = 0; i < clear; i++) {
                            dic[i] = [i]
                        }
                        dic[clear] = [];
                        dic[eod] = null;
                    } else {
                        if (code === eod) {
                            done = true;
                            return
                        }
                        if (code >= dic.length) {
                            dic.push(dic[last].concat(dic[last][0]))
                        } else if (last !== clear) {
                            dic.push(dic[last].concat(dic[code][0]))
                        }
                        d = dic[code];
                        len = d.length;
                        for (i = 0; i < len; i++) {
                            pixelBuf[pixelPos++] = d[i]
                        }
                        if (dic.length === (1 << size) && size < 12) {
                            size++
                        }
                    }
                }
            };

            function parseColourTable(count) { // get a colour table of length count  Each entry is 3 bytes, for RGB.
                var colours = [];
                for (var i = 0; i < count; i++) {
                    colours.push([st.data[st.pos++], st.data[st.pos++], st.data[st.pos++]])
                }
                return colours;
            }

            function parse() { // read the header. This is the starting point of the decode and async calls parseBlock
                var bitField;
                st.pos += 6;
                gif.width = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                gif.height = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                bitField = st.data[st.pos++];
                gif.colorRes = (bitField & 0b1110000) >> 4;
                gif.globalColourCount = 1 << ((bitField & 0b111) + 1);
                gif.bgColourIndex = st.data[st.pos++];
                st.pos++; // ignoring pixel aspect ratio. if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
                if (bitField & 0b10000000) {
                    gif.globalColourTable = parseColourTable(gif.globalColourCount)
                } // global colour flag
                setTimeout(parseBlock, 0);
            }

            function parseAppExt() { // get application specific data. Netscape added iterations and terminator. Ignoring that
                st.pos += 1;
                if ('NETSCAPE' === st.getString(8)) {
                    st.pos += 8
                } // ignoring this data. iterations (word) and terminator (byte)
                else {
                    st.pos += 3; // 3 bytes of string usually "2.0" when identifier is NETSCAPE
                    st.readSubBlocks(); // unknown app extension
                }
            };

            function parseGCExt() { // get GC data
                var bitField;
                st.pos++;
                bitField = st.data[st.pos++];
                gif.disposalMethod = (bitField & 0b11100) >> 2;
                gif.transparencyGiven = bitField & 0b1 ? true : false; // ignoring bit two that is marked as  userInput???
                gif.delayTime = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                gif.transparencyIndex = st.data[st.pos++];
                st.pos++;
            };

            function parseImg() { // decodes image data to create the indexed pixel image
                var deinterlace, frame, bitField;
                deinterlace = function(width) { // de interlace pixel data if needed
                    var lines, fromLine, pass, toline;
                    lines = pixelBufSize / width;
                    fromLine = 0;
                    if (interlacedBufSize !== pixelBufSize) { // create the buffer if size changed or undefined.
                        deinterlaceBuf = new Uint8Array(pixelBufSize);
                        interlacedBufSize = pixelBufSize;
                    }
                    for (pass = 0; pass < 4; pass++) {
                        for (toLine = interlaceOffsets[pass]; toLine < lines; toLine += interlaceSteps[pass]) {
                            deinterlaceBuf.set(pixelBuf.subarray(fromLine, fromLine + width), toLine * width);
                            fromLine += width;
                        }
                    }
                };
                frame = {}
                gif.frames.push(frame);
                frame.disposalMethod = gif.disposalMethod;
                frame.time = gif.length;
                frame.delay = gif.delayTime * 10;
                gif.length += frame.delay;
                if (gif.transparencyGiven) {
                    frame.transparencyIndex = gif.transparencyIndex
                } else {
                    frame.transparencyIndex = undefined
                }
                frame.leftPos = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                frame.topPos = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                frame.width = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                frame.height = (st.data[st.pos++]) + ((st.data[st.pos++]) << 8);
                bitField = st.data[st.pos++];
                frame.localColourTableFlag = bitField & 0b10000000 ? true : false;
                if (frame.localColourTableFlag) {
                    frame.localColourTable = parseColourTable(1 << ((bitField & 0b111) + 1))
                }
                if (pixelBufSize !== frame.width * frame.height) { // create a pixel buffer if not yet created or if current frame size is different from previous
                    pixelBuf = new Uint8Array(frame.width * frame.height);
                    pixelBufSize = frame.width * frame.height;
                }
                lzwDecode(st.data[st.pos++], st.readSubBlocksB()); // decode the pixels
                if (bitField & 0b1000000) { // de interlace if needed
                    frame.interlaced = true;
                    deinterlace(frame.width);
                } else {
                    frame.interlaced = false
                }
                processFrame(frame); // convert to canvas image
            };

            function processFrame(frame) { // creates a RGBA canvas image from the indexed pixel data.
                var ct, cData, dat, pixCount, ind, useT, i, pixel, pDat, col, frame, ti;
                frame.image = document.createElement('canvas');
                frame.image.width = gif.width;
                frame.image.height = gif.height;
                frame.image.ctx = frame.image.getContext("2d");
                ct = frame.localColourTableFlag ? frame.localColourTable : gif.globalColourTable;
                if (gif.lastFrame === null) {
                    gif.lastFrame = frame
                }
                useT = (gif.lastFrame.disposalMethod === 2 || gif.lastFrame.disposalMethod === 3) ? true : false;
                if (!useT) {
                    frame.image.ctx.drawImage(gif.lastFrame.image, 0, 0, gif.width, gif.height)
                }
                cData = frame.image.ctx.getImageData(frame.leftPos, frame.topPos, frame.width, frame.height);
                ti = frame.transparencyIndex;
                dat = cData.data;
                if (frame.interlaced) {
                    pDat = deinterlaceBuf
                } else {
                    pDat = pixelBuf
                }
                pixCount = pDat.length;
                ind = 0;
                for (i = 0; i < pixCount; i++) {
                    pixel = pDat[i];
                    col = ct[pixel];
                    if (ti !== pixel) {
                        dat[ind++] = col[0];
                        dat[ind++] = col[1];
                        dat[ind++] = col[2];
                        dat[ind++] = 255; // Opaque.
                    } else
                    if (useT) {
                        dat[ind + 3] = 0; // Transparent.
                        ind += 4;
                    } else {
                        ind += 4
                    }
                }
                frame.image.ctx.putImageData(cData, frame.leftPos, frame.topPos);
                gif.lastFrame = frame;
                if (!gif.waitTillDone && typeof gif.onload === "function") {
                    doOnloadEvent()
                } // if !waitTillDone the call onload now after first frame is loaded
            };
            // **NOT** for commercial use.
            function finnished() { // called when the load has completed
                gif.loading = false;
                gif.frameCount = gif.frames.length;
                gif.lastFrame = null;
                st = undefined;
                gif.complete = true;
                gif.disposalMethod = undefined;
                gif.transparencyGiven = undefined;
                gif.delayTime = undefined;
                gif.transparencyIndex = undefined;
                gif.waitTillDone = undefined;
                pixelBuf = undefined; // dereference pixel buffer
                deinterlaceBuf = undefined; // dereference interlace buff (may or may not be used);
                pixelBufSize = undefined;
                deinterlaceBuf = undefined;
                gif.currentFrame = 0;
                if (gif.frames.length > 0) {
                    gif.image = gif.frames[0].image
                }
                doOnloadEvent();
                if (typeof gif.onloadall === "function") {
                    (gif.onloadall.bind(gif))({
                        type: 'loadall',
                        path: [gif]
                    });
                }
                if (gif.playOnLoad) {
                    gif.play()
                }
            }

            function canceled() { // called if the load has been cancelled
                finnished();
                if (typeof gif.cancelCallback === "function") {
                    (gif.cancelCallback.bind(gif))({
                        type: 'canceled',
                        path: [gif]
                    })
                }
            }

            function parseExt() { // parse extended blocks
                const blockID = st.data[st.pos++];
                if (blockID === GIF_FILE.GCExt) {
                    parseGCExt()
                } else if (blockID === GIF_FILE.COMMENT) {
                    gif.comment += st.readSubBlocks()
                } else if (blockID === GIF_FILE.APPExt) {
                    parseAppExt()
                } else {
                    if (blockID === GIF_FILE.UNKNOWN) {
                        st.pos += 13;
                    } // skip unknow block
                    st.readSubBlocks();
                }

            }

            function parseBlock() { // parsing the blocks
                if (gif.cancel !== undefined && gif.cancel === true) {
                    canceled();
                    return
                }

                const blockId = st.data[st.pos++];
                if (blockId === GIF_FILE.IMAGE) { // image block
                    parseImg();
                    if (gif.firstFrameOnly) {
                        finnished();
                        return
                    }
                } else if (blockId === GIF_FILE.EOF) {
                    finnished();
                    return
                } else {
                    parseExt()
                }
                if (typeof gif.onprogress === "function") {
                    gif.onprogress({
                        bytesRead: st.pos,
                        totalBytes: st.data.length,
                        frame: gif.frames.length
                    });
                }
                setTimeout(parseBlock, 0); // parsing frame async so processes can get some time in.
            };

            function cancelLoad(callback) { // cancels the loading. This will cancel the load before the next frame is decoded
                if (gif.complete) {
                    return false
                }
                gif.cancelCallback = callback;
                gif.cancel = true;
                return true;
            }

            function error(type) {
                if (typeof gif.onerror === "function") {
                    (gif.onerror.bind(this))({
                        type: type,
                        path: [this]
                    })
                }
                gif.onload = gif.onerror = undefined;
                gif.loading = false;
            }

            function doOnloadEvent() { // fire onload event if set
                gif.currentFrame = 0;
                gif.nextFrameAt = gif.lastFrameAt = new Date().valueOf(); // just sets the time now
                if (typeof gif.onload === "function") {
                    (gif.onload.bind(gif))({
                        type: 'load',
                        path: [gif]
                    })
                }
                gif.onerror = gif.onload = undefined;
            }

            function dataLoaded(data) { // Data loaded create stream and parse
                st = new Stream(data);
                parse();
            }

            function loadGif(filename) { // starts the load
                var ajax = new XMLHttpRequest();
                ajax.responseType = "arraybuffer";
                ajax.onload = function(e) {
                    if (e.target.status === 404) {
                        error("File not found")
                    } else if (e.target.status >= 200 && e.target.status < 300) {
                        dataLoaded(ajax.response)
                    } else {
                        error("Loading error : " + e.target.status)
                    }
                };
                ajax.open('GET', filename, true);
                ajax.send();
                ajax.onerror = function(e) {
                    error("File error")
                };
                this.src = filename;
                this.loading = true;
            }

            function play() { // starts play if paused
                if (!gif.playing) {
                    gif.paused = false;
                    gif.playing = true;
                    playing();
                }
            }

            function pause() { // stops play
                gif.paused = true;
                gif.playing = false;
                clearTimeout(timerID);
            }

            function togglePlay() {
                if (gif.paused || !gif.playing) {
                    gif.play()
                } else {
                    gif.pause()
                }
            }

            function seekFrame(frame) { // seeks to frame number.
                clearTimeout(timerID);
                gif.currentFrame = frame % gif.frames.length;
                if (gif.playing) {
                    playing()
                } else {
                    gif.image = gif.frames[gif.currentFrame].image
                }
            }

            function seek(time) { // time in Seconds  // seek to frame that would be displayed at time
                clearTimeout(timerID);
                if (time < 0) {
                    time = 0
                }
                time *= 1000; // in ms
                time %= gif.length;
                var frame = 0;
                while (time > gif.frames[frame].time + gif.frames[frame].delay && frame < gif.frames.length) {
                    frame += 1
                }
                gif.currentFrame = frame;
                if (gif.playing) {
                    playing()
                } else {
                    gif.image = gif.frames[gif.currentFrame].image
                }
            }

            function playing() {
                var delay;
                var frame;
                if (gif.playSpeed === 0) {
                    gif.pause();
                    return;
                } else {
                    if (gif.playSpeed < 0) {
                        gif.currentFrame -= 1;
                        if (gif.currentFrame < 0) {
                            gif.currentFrame = gif.frames.length - 1
                        }
                        frame = gif.currentFrame;
                        frame -= 1;
                        if (frame < 0) {
                            frame = gif.frames.length - 1
                        }
                        delay = -gif.frames[frame].delay * 1 / gif.playSpeed;
                    } else {
                        gif.currentFrame += 1;
                        gif.currentFrame %= gif.frames.length;
                        delay = gif.frames[gif.currentFrame].delay * 1 / gif.playSpeed;
                    }
                    gif.image = gif.frames[gif.currentFrame].image;
                    timerID = setTimeout(playing, delay);
                }
            }
            var gif = { // the gif image object
                onload: null, // fire on load. Use waitTillDone = true to have load fire at end or false to fire on first frame
                onerror: null, // fires on error
                onprogress: null, // fires a load progress event
                onloadall: null, // event fires when all frames have loaded and gif is ready
                paused: false, // true if paused
                playing: false, // true if playing
                waitTillDone: true, // If true onload will fire when all frames loaded, if false, onload will fire when first frame has loaded
                loading: false, // true if still loading
                firstFrameOnly: false, // if true only load the first frame
                width: null, // width in pixels
                height: null, // height in pixels
                frames: [], // array of frames
                comment: "", // comments if found in file. Note I remember that some gifs have comments per frame if so this will be all comment concatenated
                length: 0, // gif length in ms (1/1000 second)
                currentFrame: 0, // current frame. 
                frameCount: 0, // number of frames
                playSpeed: 1, // play speed 1 normal, 2 twice 0.5 half, -1 reverse etc...
                lastFrame: null, // temp hold last frame loaded so you can display the gif as it loads
                image: null, // the current image at the currentFrame
                playOnLoad: true, // if true starts playback when loaded
                // functions
                load: loadGif, // call this to load a file
                cancel: cancelLoad, // call to stop loading
                play: play, // call to start play
                pause: pause, // call to pause
                seek: seek, // call to seek to time
                seekFrame: seekFrame, // call to seek to frame
                togglePlay: togglePlay, // call to toggle play and pause state
            };
            return gif;
        }
















        /*=========================================================================
        End of gif reader

        */

        const mouse = {
            bounds: null,
            x: 0,
            y: 0,
            button: false
        };

        function mouseEvents(e) {
            const m = mouse;
            m.bounds = canvas.getBoundingClientRect();
            m.x = e.pageX - m.bounds.left - scrollX;
            m.y = e.pageY - m.bounds.top - scrollY;
            mouse.x = e.pageX;

            m.button = e.type === "mousedown" ? true : e.type === "mouseup" ? false : m.button;
        }
        ["down", "up", "move"].forEach(name => document.addEventListener("mouse" + name, mouseEvents));
    </script>

</body>

</html>